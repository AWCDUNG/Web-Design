const STAT_CARD_WARNING = {
    // Mapping gi·ªØa t√™n parameter v√† class name c·ªßa card
    cardMapping: {
        temperature: 'temperature',
        temperatureIndoor: 'temperature-indoor',
        humidity: 'humidity',
        pm25: 'air-quality',
        pm10: 'air-quality-pm10',
        coGas: 'co-gas',
        lpgGas: 'lpg-gas',
        ch4Gas: 'ch4-gas',
        pressure: 'pressure',
        speed: 'speed',
        acceleration: 'acceleration',
        tiltAngle: 'tilt-angle',
        lightLeak: 'light-leak',
        flame: 'flame-sensor'
    },

    // CSS styles cho c√°c warning levels - CH·ªà THAY ƒê·ªîI M√ÄU S·∫ÆC
    warningStyles: {
        normal: {
            // Kh√¥ng thay ƒë·ªïi g√¨ cho tr·∫°ng th√°i b√¨nh th∆∞·ªùng
        },
        warning: {
            backgroundColor: '#fefce8',
            borderColor: '#fbbf24'
        },
        danger: {
            backgroundColor: '#fef2f2',
            borderColor: '#ef4444'
        }
    },

    // Kh·ªüi t·∫°o CSS animations
    initializeStyles() {
        // Ki·ªÉm tra xem style ƒë√£ ƒë∆∞·ª£c th√™m ch∆∞a
        if (document.getElementById('cardWarningStyles')) return;

        const styleSheet = document.createElement('style');
        styleSheet.id = 'cardWarningStyles';
        styleSheet.textContent = `
            /* Ch·ªâ th√™m class ƒë·ªÉ nh·∫≠n d·∫°ng warning states */
            .stat-card.warning-active {
                background-color: #fefce8 !important;
                border-color: #fbbf24 !important;
            }
            
            .stat-card.danger-active {
                background-color: #fef2f2 !important;
                border-color: #ef4444 !important;
            }
            
            /* Thay ƒë·ªïi m√†u ch·ªØ s·ªë */
            .stat-card.warning-active .stat-number {
                color: #d97706 !important;
            }
            
            .stat-card.danger-active .stat-number {
                color: #dc2626 !important;
            }
        `;
        document.head.appendChild(styleSheet);
    },

    // √Åp d·ª•ng style cho card - CH·ªà THAY ƒê·ªîI M√ÄU S·∫ÆC
    applyCardStyle(cardElement, level) {
        if (!cardElement) {
            console.warn('Card element not found');
            return;
        }

        try {
            // Reset classes
            cardElement.classList.remove('warning-active', 'danger-active');
            
            // Ch·ªâ th√™m class ƒë·ªÉ thay ƒë·ªïi m√†u, kh√¥ng ƒë·ªông v√†o style
            if (level === 'warning') {
                cardElement.classList.add('warning-active');
            } else if (level === 'danger') {
                cardElement.classList.add('danger-active');
            }
            
            console.log(`‚úÖ Applied ${level} style to card:`, cardElement.className);
            
        } catch (error) {
            console.error('Error applying card style:', error);
        }
    },

    // T√¨m card element d·ª±a tr√™n parameter name - C·∫¢I THI·ªÜN
    findCardElement(paramName) {
        const cardClass = this.cardMapping[paramName];
        if (!cardClass) {
            console.warn(`No card mapping found for param: ${paramName}`);
            return null;
        }
        
        // Th·ª≠ nhi·ªÅu c√°ch t√¨m card element
        let cardElement = document.querySelector(`.stat-card.${cardClass}`);
        
        if (!cardElement) {
            // Th·ª≠ t√¨m theo class ri√™ng l·∫ª
            cardElement = document.querySelector(`.${cardClass}`);
        }
        
        if (!cardElement) {
            // Th·ª≠ t√¨m theo data attribute
            cardElement = document.querySelector(`[data-param="${paramName}"]`);
        }
        
        if (!cardElement) {
            console.warn(`Card element not found for: ${paramName} (class: ${cardClass})`);
        }
        
        return cardElement;
    },

    // Reset t·∫•t c·∫£ cards v·ªÅ tr·∫°ng th√°i b√¨nh th∆∞·ªùng - C·∫¢I THI·ªÜN
    resetAllCards() {
        const cards = document.querySelectorAll('.stat-card');
        
        if (cards.length === 0) {
            console.warn('No stat cards found to reset');
            return;
        }
        
        cards.forEach(card => {
            try {
                // Kh√¥i ph·ª•c style g·ªëc n·∫øu c√≥
                if (card.dataset.originalStyle) {
                    card.style.cssText = card.dataset.originalStyle;
                } else {
                    this.applyCardStyle(card, 'normal');
                }
                
                // X√≥a title tooltip
                card.removeAttribute('title');
                
            } catch (error) {
                console.error('Error resetting card:', error, card);
            }
        });
        
        console.log(`üîÑ Reset ${cards.length} cards to normal state`);
    },

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i card d·ª±a tr√™n warnings
    updateCardStates(warnings) {
        try {
            // Reset t·∫•t c·∫£ cards tr∆∞·ªõc
            this.resetAllCards();
            
            if (!warnings || warnings.length === 0) {
                console.log('No warnings to apply');
                return;
            }
            
            // √Åp d·ª•ng warning cho c√°c cards c√≥ v·∫•n ƒë·ªÅ
            warnings.forEach(warning => {
                const cardElement = this.findCardElement(warning.param);
                if (cardElement) {
                    this.applyCardStyle(cardElement, warning.level);
                    
                    // Th√™m tooltip n·∫øu mu·ªën
                    cardElement.title = warning.message;
                    
                    console.log(`üìä Updated card: ${warning.param} - ${warning.level}`);
                } else {
                    console.warn(`Card not found for param: ${warning.param}`);
                }
            });
            
        } catch (error) {
            console.error('Error updating card states:', error);
        }
    },

    // X·ª≠ l√Ω warning ƒë·∫∑c bi·ªát cho flame v√† light leak
    handleSpecialWarnings(data) {
        const specialWarnings = [];
        
        try {
            // Flame detection
            const flameDetected = data.flameDetected === 'Yes' || 
                                data.flame_detected === 1 || 
                                data.flame_detected === '1' ||
                                data.flameDetected === 1;
            
            if (flameDetected) {
                specialWarnings.push({
                    param: 'flame',
                    level: 'danger',
                    message: 'FIRE DETECTED!'
                });
            }
            
            // Light leak detection
            const lightLeak = data.lightLeakDetected === 'Yes' || 
                             data.light_leak_detected === 1 || 
                             data.light_leak_detected === '1' ||
                             data.lightLeakDetected === 1;
            
            if (lightLeak) {
                specialWarnings.push({
                    param: 'lightLeak',
                    level: 'warning',
                    message: 'Light leak detected!'
                });
            }
            
        } catch (error) {
            console.error('Error handling special warnings:', error);
        }
        
        return specialWarnings;
    },

    // H√†m ch√≠nh ƒë·ªÉ c·∫≠p nh·∫≠t t·∫•t c·∫£ card warnings - C·∫¢I THI·ªÜN
    updateAllCardWarnings(data) {
        try {
            // Kh·ªüi t·∫°o styles n·∫øu ch∆∞a c√≥
            this.initializeStyles();
            
            // Ki·ªÉm tra xem c√≥ cards kh√¥ng
            const cards = document.querySelectorAll('.stat-card');
            if (cards.length === 0) {
                console.warn('No stat cards found in DOM');
                return [];
            }
            
            // L·∫•y warnings t·ª´ WARNING_SYSTEM n·∫øu c√≥
            let allWarnings = [];
            
            if (window.warningSystem && window.warningSystem.WARNING_SYSTEM) {
                const result = window.warningSystem.WARNING_SYSTEM.checkAll(data);
                allWarnings = result.warnings;
            } else {
                // N·∫øu kh√¥ng c√≥ WARNING_SYSTEM, t·ª± ki·ªÉm tra c∆° b·∫£n
                console.warn('WARNING_SYSTEM not found, using basic threshold check');
                allWarnings = this.basicThresholdCheck(data);
            }
            
            // Th√™m special warnings
            const specialWarnings = this.handleSpecialWarnings(data);
            allWarnings = [...allWarnings, ...specialWarnings];
            
            // C·∫≠p nh·∫≠t card states
            this.updateCardStates(allWarnings);
            
            return allWarnings;
            
        } catch (error) {
            console.error('Error in updateAllCardWarnings:', error);
            return [];
        }
    },

    // Ki·ªÉm tra ng∆∞·ª°ng c∆° b·∫£n n·∫øu kh√¥ng c√≥ WARNING_SYSTEM
    basicThresholdCheck(data) {
        const warnings = [];
        const basicThresholds = {
            temperature: { warning: [5, 55], danger: [-10, 75] },
            temperatureIndoor: { warning: [10, 45], danger: [0, 65] },
            humidity: { warning: [20, 90], danger: [0, 100] },
            pm25: { warning: [51, 150], danger: [151, 1000] },
            pm10: { warning: [51, 200], danger: [201, 1000] },
            coGas: { warning: [101, 500], danger: [501, 2000] },
            lpgGas: { warning: [51, 200], danger: [201, 1000] },
            ch4Gas: { warning: [51, 150], danger: [151, 500] },
            pressure: { warning: [990, 1030], danger: [950, 1070] },
            speed: { warning: [61, 90], danger: [91, 200] },
            acceleration: { warning: [2.1, 4], danger: [4.1, 10] },
            tiltAngle: { warning: [16, 30], danger: [31, 90] }
        };
        
        Object.keys(basicThresholds).forEach(param => {
            if (data[param] !== undefined && data[param] !== null) {
                const value = parseFloat(data[param]);
                const thresholds = basicThresholds[param];
                
                if (isNaN(value)) return;
                
                const [dangerMin, dangerMax] = thresholds.danger;
                const [warningMin, warningMax] = thresholds.warning;
                
                if (value <= dangerMin || value >= dangerMax) {
                    warnings.push({ param, level: 'danger', message: `${param}: ${value}` });
                } else if (value <= warningMin || value >= warningMax) {
                    warnings.push({ param, level: 'warning', message: `${param}: ${value}` });
                }
            }
        });
        
        return warnings;
    },

    // H√†m debug ƒë·ªÉ ki·ªÉm tra DOM
    debugCards() {
        console.log('üîç Debug: Checking card elements...');
        const cards = document.querySelectorAll('.stat-card');
        console.log(`Found ${cards.length} stat cards`);
        
        cards.forEach((card, index) => {
            console.log(`Card ${index}:`, {
                classes: card.className,
                display: window.getComputedStyle(card).display,
                visibility: window.getComputedStyle(card).visibility,
                opacity: window.getComputedStyle(card).opacity
            });
        });
        
        // Ki·ªÉm tra mapping
        Object.keys(this.cardMapping).forEach(param => {
            const cardElement = this.findCardElement(param);
            console.log(`${param}: ${cardElement ? 'FOUND' : 'NOT FOUND'}`);
        });
    },

    // H√†m ti·ªán √≠ch ƒë·ªÉ test
    testCardColors() {
        console.log('üß™ Testing card colors...');
        
        // Debug tr∆∞·ªõc khi test
        this.debugCards();
        
        // Test data v·ªõi c√°c gi√° tr·ªã v∆∞·ª£t ng∆∞·ª°ng
        const testData = {
            temperature: 60, // danger
            humidity: 95,    // warning
            pm25: 200,       // danger
            speed: 85,       // warning
            flameDetected: 'Yes' // danger
        };
        
        this.updateAllCardWarnings(testData);
        
        // Reset sau 5 gi√¢y
        setTimeout(() => {
            console.log('üîÑ Resetting cards to normal...');
            this.resetAllCards();
        }, 5000);
    }
};

// Auto-initialize khi DOM ready
document.addEventListener('DOMContentLoaded', function() {
    try {
        STAT_CARD_WARNING.initializeStyles();
        console.log('üé® Stat Card Warning System initialized!');
        
        // Debug sau khi DOM loaded
        setTimeout(() => {
            STAT_CARD_WARNING.debugCards();
        }, 1000);
        
    } catch (error) {
        console.error('Error initializing Stat Card Warning System:', error);
    }
});

// Export functions ƒë·ªÉ s·ª≠ d·ª•ng
window.statCardWarning = {
    updateCards: (data) => STAT_CARD_WARNING.updateAllCardWarnings(data),
    resetCards: () => STAT_CARD_WARNING.resetAllCards(),
    testColors: () => STAT_CARD_WARNING.testCardColors(),
    debugCards: () => STAT_CARD_WARNING.debugCards(),
    STAT_CARD_WARNING
};

// Integration v·ªõi WARNING_SYSTEM n·∫øu c√≥ - C·∫¢I THI·ªÜN
try {
    if (window.warningSystem) {
        const originalCheckWarnings = window.warningSystem.checkWarnings;
        
        if (originalCheckWarnings) {
            window.warningSystem.checkWarnings = function(data) {
                const result = originalCheckWarnings.call(this, data);
                // C·∫≠p nh·∫≠t card colors
                STAT_CARD_WARNING.updateAllCardWarnings(data);
                return result;
            };
            
            console.log('üîó Integrated with existing WARNING_SYSTEM');
        }
    }
} catch (error) {
    console.error('Error integrating with WARNING_SYSTEM:', error);
}

console.log('‚úÖ Stat Card Warning System loaded successfully!');